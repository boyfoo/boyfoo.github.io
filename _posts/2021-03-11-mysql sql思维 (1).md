---
layout: post
title: 'mysql sql思维 (1)'
date: 2021-03-11
author: boyfoo
tags: mysql
---

#### 表结构

```sql
# id 名称 类型 浏览量
DROP TABLE IF EXISTS `products`;
CREATE TABLE `products` (
  `p_id` int(11) NOT NULL AUTO_INCREMENT,
  `p_name` varchar(30) DEFAULT NULL,
  `p_type` varchar(20) DEFAULT NULL,
  `p_view` int(11) DEFAULT NULL,
  PRIMARY KEY (`p_id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

INSERT INTO `products` VALUES ('1', '西瓜', '水果类', '21');
INSERT INTO `products` VALUES ('2', '瓜子', '干果类', '32');
INSERT INTO `products` VALUES ('22', '苹果', '水果类', '32');
INSERT INTO `products` VALUES ('28', '桔子', '水果类', '33');
INSERT INTO `products` VALUES ('32', '香蕉', '水果类', '21');
INSERT INTO `products` VALUES ('35', '花生', '干果类', '3');
INSERT INTO `products` VALUES ('37', '猪肉', '生鲜类', '5');
INSERT INTO `products` VALUES ('48', '牛肉', '生鲜类', '23');
INSERT INTO `products` VALUES ('60', '开心果', '干果类', '56');
INSERT INTO `products` VALUES ('61', '鸡翅', '生鲜类', '23');
INSERT INTO `products` VALUES ('77', '樱桃', '水果类', '41');
INSERT INTO `products` VALUES ('87', '杜蕾斯', '其他类', '123');
INSERT INTO `products` VALUES ('102', '开瓶器', '其他类', '88');
INSERT INTO `products` VALUES ('114', '五花肉', '生鲜类', '4');
```

#### 会话变量

```sql
set @key = value;       # 赋值, mysql中 “:=” 为赋值; “=”为比较是否相等；但是在set中可以省略“:”符号,
select @key := value    # 赋值 
select @key;            # 查询
select @key as name;
```

只要会话不结束，变量会一直存在

可用于给查询结果加上序号

```sql
select p_name, p_view, IFNULL(@rownum:=@rownum+1,@rownum:=1) as num 
from products 
ORDER BY p_view DESC;
```
`IFNULL`函数为第一个参数的运行结果如果为null,而运行第二个函数，因为一开始`@rownum`未被赋值，所有第一次`@rownum:=@rownum+1`值为null，因此运行`@rownum:=1`赋值为1，后续行`@rownum:=@rownum+1`不断累加

此方法在同一个会话的每次查询中，`@rownum` 都会不断累计，修改为

```sql
select  p_name, p_view, @rownum:=@rownum+1 as num 
from products a, (select @rownum:=0) b 
ORDER BY p_view DESC;
```

在`from`中使用`select @key`初始化，这样每次查询的时候都会重新初始化值

#### 每个类型各取N条

```sql
SELECT p_name, p_type, p_view, num 
FROM 
    (
        select  p_name, p_type, p_view, IF(@bak=p_type,@num := @num + 1,@num := 1) as num,@bak:=p_type 
        FROM products a, (select @num := 0, @bak := '') b 
        ORDER BY p_type, p_view DESC
    ) c 
WHERE num <= 2;
```

内部子查询，先根据类型`p_type`和点击量`p_view`排序，这样排序的结果每个类型直接是相邻的，然后每个给类型按顺序设置行号`num`，当遇到新的类型名称后，另起行号`num`；外部查询根据`where`条件过去行号大于2的列，代表只取出了每个类型的前2列