---
layout: post
title: '二进制部署 k8s'
date: 2020-10-22
author: boyfoo
tags: k8s
---

### 一、准备工作

#### 1.软件信息

* Docker version 18.06.3-ce
* CentOS 7.6.1811
* K8s 16

#### 2.关闭防火墙
<!-- tar xvf TLS.tar.gz -->
* centos

```bash
$ systemctl stop firewalld
$ systemctl disable firewalld
```

* ubuntu

`TODO`

#### 3.关闭交换分区

* centos

```bash
# 临时关闭
$ swapoff -a
```
```bash
# 永久关闭 注释文件内容
$ vim /etc/fstab
#/swapfile none swap defaults 0 0
```
```bash
#查看关闭结果
$ free -m
# Swap 都为0表示关闭成功
Swap:             0           0           0
```

* ubuntu

`TODO`

#### 4.配置主机名称名称解析

```bash
$ vim /etc/hosts

192.168.205.120 node01
192.168.205.121 node02
```


#### 5.关闭 setlinux

* centos

```bash
# 临时
$ setenforce 0

# 永久
$ vim /etc/selinux/config
SELINUX=disabled
```

* ubuntu

`TODO`

#### 6.配置时间

以主节点时间为准，副节点获取主节点的时间为准

* centos

主节点:

```bash
$ yum install chrony -y

$ vim /etc/chrony.conf
# 以本地时间地址 注释其他server
server 127.127.1.0 iburst
# 允许该网段的副接口来请求 集群的网段
allow 192.168.205.0/24
local stratum 10

$ systemctl restart chronyd
$ systemctl enable chronyd

# 查看进程端口是否被监听
$ ss -unl | grep 123
```

副节点:

```bash
$ yum install chrony -y

$ vim /etc/chrony.conf
# 以本地时间地址 注释其他server
server [主节点IP] iburst

$ systemctl restart chronyd
$ systemctl enable chronyd

# 查看结果 ^*开头表示成功
$ chronyc sources
^* node01                       10   6    17    41  +8305ns[  +54us] +/-  160us
```

* ubuntu
`TODO`

#### 7.桥接IPV4流量传递到iptables的链

* centos

```bash
$ cat > /etc/sysctl.d/k8s.conf << EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF

# 刷新生效
$ sudo sysctl --system
```
* ubuntu
`TODO`

### 二、自签证书

#### 1.自建CA

方式有2种：
* openssl
* cfssl

`k8s` 官方推荐使用 `cfssl`

下载cfssl工具组件

```bash
$ curl -s -L -o /bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
$ curl -s -L -o /bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
$ curl -s -L -o /bin/cfssl-certinfo https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64

# 赋予运行权限
$ chmod +x /bin/cfssl*
```
#### 2.颁发ECTD证书

文件统一生成在`/opt/cfssl_file/`下

创建证书颁发机构：

`$ vim etcd/ca-csr.json`

```json
{
    "CN": "etcd CA",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Beijing",
            "ST": "Beijing"
        }
    ]
}
```

`$ vim etcd/ca-config.json` 

```json
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "www": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}
```

填写颁发表单：

`$ vim etcd/server-csr.json`

```json
{
    "CN": "etcd",
    "hosts": [
        "192.168.205.120",
        "192.168.205.121"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "BeiJing",
            "ST": "BeiJing"
        }
    ]
}
```

颁发证书:

```bash
$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server

# 查看生成的证书文件 
$ ls *pem
```

安装`etcd`:

目前演示只在主机安装`etcd`，其他节点上只用`etcdcli`客户端，统一访问主节点的`etcd`，主节点生成证书启动后，证书要复制到其他节点上，供`etcdcli`客户端使用

```bash
$ yum install -y etcd-3.2.28-1.el7_8

# 查看系统脚本 修改ExecStart部分 和 证书配置文件
$ vim /usr/lib/systemd/system/etcd.service
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
EnvironmentFile=/etc/etcd/etcd.conf
ExecStart=/usr/bin/etcd \
        --name=${ETCD_NAME} \
        --data-dir=${ETCD_DATA_DIR} \
        --listen-peer-urls=${ETCD_LISTEN_PEER_URLS} \
        --listen-client-urls=${ETCD_LISTEN_CLIENT_URLS},http://127.0.0.1:2379 \
        --advertise-client-urls=${ETCD_ADVERTISE_CLIENT_URLS} \
        --initial-advertise-peer-urls=${ETCD_INITIAL_ADVERTISE_PEER_URLS} \
        --initial-cluster=${ETCD_INITIAL_CLUSTER} \
        --initial-cluster-token=${ETCD_INITIAL_CLUSTER_TOKEN} \
        --initial-cluster-state=new \
        --cert-file=/opt/cfssl_file/etcd/server.pem \
        --key-file=/opt/cfssl_file/etcd/server-key.pem \
        --peer-cert-file=/opt/cfssl_file/etcd/server.pem \
        --peer-key-file=/opt/cfssl_file/etcd/server-key.pem \
        --trusted-ca-file=/opt/cfssl_file/etcd/ca.pem \
        --peer-trusted-ca-file=/opt/cfssl_file/etcd/ca.pem
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
```

修改配置文件

```bash
$ vim /etc/etcd/etcd.conf
ETCD_LISTEN_PEER_URLS="https://192.168.205.120:2380"
ETCD_LISTEN_CLIENT_URLS="https://192.168.205.120:2379"
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.205.120:2379"
ETCD_NAME="node01" # 节点名称
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.205.120:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.205.120:2379"
ETCD_INITIAL_CLUSTER="node01=https://localhost:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"

systemctl daemon-reload
systemctl restart etcd.service
systemctl enable etcd.service
```

其他节点 `etcdcli` 客户端访问

先拷贝证书到节点上

```bash
$ scp -r /opt/cfssl_file/etcd/ root@node02:/opt/cfssl_file/etcd/
```

```bash
# 其他节点访问主机etcd
$ etcdctl --ca-file=/opt/cfssl_file/etcd/ca.pem --cert-file=/opt/cfssl_file/etcd/server.pem --key-file=/opt/cfssl_file/etcd/server-key.pem --endpoints=https://192.168.205.120:2379 get zx

# 查看集群状态 (若失败要带上秘钥)
$ etcdctl --endpoints=https://192.168.205.120:2379 cluster-health
```

#### 3.颁发apiserver证书

主节点颁布证书:

```bash
$ vim k8s/ca-csr.json
{
    "CN": "kubernetes",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Beijing",
            "ST": "Beijing",
      	    "O": "k8s",
            "OU": "System"
        }
    ]
}

$ vim k8s/ca-config.json
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "kubernetes": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}
# k8s apiserver证书配置
$ vim k8s/server-csr.json
{
    "CN": "kubernetes",
    "hosts": [
      "10.0.0.1",
      "127.0.0.1",
      "kubernetes",
      "kubernetes.default",
      "kubernetes.default.svc",
      "kubernetes.default.svc.cluster",
      "kubernetes.default.svc.cluster.local",
      "192.168.205.121",
      "192.168.205.120"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "BeiJing",
            "ST": "BeiJing",
            "O": "k8s",
            "OU": "System"
        }
    ]
}
# k8s代理证书配置
$ vim kube-proxy-csr.json
{
  "CN": "system:kube-proxy",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing",
      "ST": "BeiJing",
      "O": "k8s",
      "OU": "System"
    }
  ]
}

# 生成
$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server
$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy
```

自行下载`k8s`

配置`apiserver`：

```bash
$ vim /usr/lib/systemd/system/kube-apiserver.service
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf
ExecStart=/opt/kubernetes/bin/kube-apiserver $KUBE_APISERVER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target

$ vim /opt/kubernetes/cfg/kube-apiserver.conf
KUBE_APISERVER_OPTS="--logtostderr=false \  // 错误信息是否打印到控制台
--v=2 \ // 日志级别
--log-dir=/opt/kubernetes/logs \    // 日志文件位置
--etcd-servers=https://192.168.205.120:2379 \	//etcd地址(多个逗号隔开)
--bind-address=192.168.205.120 \	// 当前主机地址
--secure-port=6443 \
--advertise-address=192.168.205.120 \	// 通告地址 告诉别人来访问这个 正常与主机地址一样
--allow-privileged=true \   // 是否已超级管理员权限创建容器
--service-cluster-ip-range=10.0.0.0/24 \    // 启动service服务的虚拟网段
--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \    // 允许使用的插件
--authorization-mode=RBAC,Node \    // 授权模式
--enable-bootstrap-token-auth=true \    // 自动颁发证书
--token-auth-file=/opt/kubernetes/cfg/token.csv \   // 自动颁发证书用到的特点用户的信息
--service-node-port-range=30000-32767 \     // service端口范围
--kubelet-client-certificate=/opt/cfssl_file/k8s/server.pem \   // 访问kubelet使用的证书
--kubelet-client-key=/opt/cfssl_file/k8s/server-key.pem \
--tls-cert-file=/opt/cfssl_file/k8s/server.pem  \               // 访问apiservice使用的证书
--tls-private-key-file=/opt/cfssl_file/k8s/server-key.pem \
--client-ca-file=/opt/cfssl_file/k8s/ca.pem \
--service-account-key-file=/opt/cfssl_file/k8s/ca-key.pem \
--etcd-cafile=/opt/cfssl_file/etcd/ca.pem \                     // 访问 etcd 使用的证书
--etcd-certfile=/opt/cfssl_file/etcd/server.pem \
--etcd-keyfile=/opt/cfssl_file/etcd/server-key.pem \
--audit-log-maxage=30 \
--audit-log-maxbackup=3 \
--audit-log-maxsize=100 \
--audit-log-path=/opt/kubernetes/logs/k8s-audit.log"

$ systemctl daemon-reload
```

配置`kube-controller-manager`

```bash
$ vim /usr/lib/systemd/system/kube-controller-manager.service
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf
ExecStart=/opt/kubernetes/bin/kube-controller-manager $KUBE_CONTROLLER_MANAGER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target

$ vim /opt/kubernetes/cfg/kube-controller-manager.conf
KUBE_CONTROLLER_MANAGER_OPTS="--logtostderr=false \
--v=2 \
--log-dir=/opt/kubernetes/logs \
--leader-elect=true \   // 多个apiservice 自动选一个调度
--master=127.0.0.1:8080 \ // 多个apiservice ip地址 因为在当前主机 可以写ip也可以写127
--address=127.0.0.1 \   \\ 监听的ip地址
--allocate-node-cidrs=true \    // 是不是支持网络插件
--cluster-cidr=10.244.0.0/16 \  // 基于网络插件分配的网络地址
--service-cluster-ip-range=10.0.0.0/24 \    // 客户端的地址范围
--cluster-signing-cert-file=/opt/cfssl_file/k8s/ca.pem \
--cluster-signing-key-file=/opt/cfssl_file/k8s/ca-key.pem  \
--root-ca-file=/opt/cfssl_file/k8s/ca.pem \
--service-account-private-key-file=/opt/cfssl_file/k8s/ca-key.pem \
--experimental-cluster-signing-duration=87600h0m0s"
```

配置`kube-controller-manager`

```bash
$ vim cfg/kube-scheduler.conf
KUBE_SCHEDULER_OPTS="--logtostderr=false \
--v=2 \
--log-dir=/opt/kubernetes/logs \
--leader-elect \
--master=127.0.0.1:8080 \
--address=127.0.0.1"

$ vim /usr/lib/systemd/system/kube-scheduler.service
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf
ExecStart=/opt/kubernetes/bin/kube-scheduler $KUBE_SCHEDULER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target

$ systemctl daemon-reload
```

#### 4. 启动master

```bash
$ systemctl start kube-apiserver.service
$ systemctl enable kube-apiserver.service

$ systemctl start kube-scheduler.service
$ systemctl enable kube-scheduler.service

$ systemctl start kube-controller-manager.service
$ systemctl enable kube-controller-manager.service

# 查看服务是否正常运行
$ ps aux | grep kube
```

#### 5. master 自动颁发证书

`kube-apiserver.conf` 配置文件的 `enable-bootstrap-token-auth` 和 `token-auth-file` 要配置正确

配置授权文件:

```
$ vim /opt/kubernetes/cfg/token.csv
c47ffb939f5ca36231d9e3121a252940,kubelet-bootstrap,10001,"system:node-bootstrapper"
```

文本内容用`,`号隔开分别代表:秘钥,用户名,过期时间,命名空间

给`kubelet-bootstrap`授权:
```bash
$ kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap
clusterrolebinding.rbac.authorization.k8s.io/kubelet-bootstrap created
```